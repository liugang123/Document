- #### 窗口基础
```
1.窗口(window)是将无限流切割为有限流的一种方式，它会将流数据分发到有限大小的桶(bucket)中进行分析
2.窗口主要分为两大类：时间窗口(Time Window)和计数窗口(Count Window)
3.滚动窗口(tumbling window)
  * 将事件分配到固定长度且互不重叠的桶中，在窗口边界通过后，所有事件会发送给计算函数进行处理
  * 基于数量的滚动窗口定义了在触发计算前需要集齐多少条事件
  * 基于时间的滚动窗口定义了在桶中缓冲数据的时间间隔
4.滑动窗口(sliding window)
  * 将事件分配到大小固定且允许相互重叠的桶中，每个事件可能会同时属于多个桶
  * 可以通过指定窗口长度和滑动间隔来定义滑动窗口，滑动窗口是滚动窗口的更广义的一种形式
5.会话窗口(session window)
  * 由一系列事件组合一个指定长度的timeout间隙组成，也就是一段时间没有接收到新数据就会生成新的窗口
  * 会话窗口根据会话间隔(session gap)将事件分为不同的会话，该间隔值定义了会话在关闭前的非活动时间长度
```

- #### 不同类型的窗口
```
1.滚动时间窗口(tumbling time window)
  .timeWindow(Time.secondes(15));  
2.滑动时间窗口(sliding time window)
  .timeWindow(Time.seconds(15),Time.seconds(5));
3.滚动计数窗口(tumbling count window)
  .countWindow(5);
4.滑动计数窗口(sliding count window)
  .countWindow(10,2); 
5.会话窗口(session window)
  .window(EventTimeSessionWindows.withGap(Time.minutes(10)));
```

- #### 窗口API
```
1.可以使用.window()来定义一个窗口，然后基于这个window去做一些聚合或者其它处理操作。
  window()函数必须在keyBy之后才能使用
2.FLink提供了更加简单的.timeWindow()和.countWindow()方法，用于定义时间窗口和计数窗口
3.窗口函数(window function)定义了针对窗口内元素的计算逻辑，可用于窗口的函数类型有两种：
  * 增量聚合函数
    > 窗口内以状态形式存储某个值且需要根据每个加入窗口的元素对改值进行更新
    > 此类函数通常会十分节省空间且最终会将聚合值作为单个结果发送出去
    > ReduceFunction和AggregateFunction就属于增量聚合函数
  * 全量聚合函数
    > 它会收集窗口内的所有元素，并在执行计算时对它们进行遍历
    > 虽然全量窗口函数通常需要占用更多空间，但它和增量聚合函数相比，支持更复杂的逻辑
    > ProcessWindowFunction就是一个全量窗口函数
4.其他可选API
  * .trigger()：触发器，定义窗口什么时候关闭，触发计算结果并输出
  * .evictor()：移除器，定义移除某些数据的逻辑
  * .allowedLateness()：允许处理迟到的数据
  * .sideOutputLateData()：将迟到的数据放入侧输出流
  * .getSideOutput()：获取侧输出流
```

- #### 窗口生命周期
```
1.元素会通过WindowAssigner分配给窗口，触发器决定何时对窗口执行计算，而实际的计算逻辑则由窗口函数决定
2.窗口算子在处理到达的数据流元素时通常需要新建和删除一些窗口，窗口会在WindowAssigner首次向它分配元素时创建
3.窗口内的状态由以下部分组成：
  * 窗口内容：
    > 包含了分配给窗口的元素，或当窗口算子配置了ReduceFunction或AggregateFunction时增量聚合所得到的结果
  * 窗口对象
    > WindowAssigner会返回零个、一个或多个窗口对象，窗口算子会根据返回的对象对元素进行分组
    > 窗口对象中保存着用于区分窗口的信息，每个窗口对象都有一个结束时间戳，它定义了可以安全删除窗口及其状态的时间点 
  * 触发器计时器
    > 可以在触发器中注册计时器，用于在将来某个时间点触发回调(如对窗口进行计算或清理其内容)
    > 计时器由窗口算子负责维护
  * 触发器中的自定义状态
    > 触发器中可以定义和使用针对每个窗口、每个键值的自定义状态
    > 自定义状态并非由窗口算子进行维护，而是完全由触发器来控制
4.窗口算子会在窗口结束时间到达时删除窗口，该时间是处理时间还是事件时间取决于WindowAssigner.isEventTime()方法的返回值
5.当窗口删除时，窗口算子会自动清楚窗口内容并丢弃窗口对象
```

- #### 时间语义
```
1.处理时间
  * 当前流处理算子所在机器上的本地时钟时间
  * 基于处理时间的窗口会包含那些恰好在一段时间内到达窗口算子的事件，时间段是按照机器时间测量的
2.事件时间
  * 事件时间是数据流中事件实际发生的时间，它以附加在数据流中的事件的时间戳为依据
  * 事件时间戳在事件数据进入流处理管道之前就存在，即使事件有延迟，事件时间窗口也能准确的将事件分配到窗口中，反应真实发生的情况
3.在事件时间模式下，Flink流式应用处理的所有记录都必须包含时间戳，
  时间戳将记录和特定时间点进行关联，这些时间点通常是记录所对应事件的发生时间
```
  
- #### 水位线  
```
1.除了记录的时间戳，Flink基于事件时间的应用还必须提供水位线，水位线用于在事件时间应用中推断每个任务当前的事件时间
2.水位线是一个全局进度指标，表示确信不会再有延迟事件到来的某个时间点
3.水位线提供了一个逻辑时钟，用来通知系统当前的事件时间。算子一旦收到某个水位线，就相当于接到信号：
    某个特定时间区间的时间戳已经到齐，可以触发窗口计算或对接收的数据进行排序了
4.水位线特点
 * 水位线是一条特殊的数据记录
 * 必须单调递增，为了确保任务中的事件时间时钟正确前进，不会倒退
 * 和记录的时间戳存在联系，一个时间戳为T的水位线表示，接下来所有记录的时间戳一定都大于T
```

- #### 生成水位线
```
1.时间戳和水位线通常都是在数据流刚进入流处理应用的时候分配和生成的
2.DataStream应用可以通过三种方式分配时间戳和生成水位线
  * 在数据源完成
    > 可以使用SourceFunction在应用读入数据流的时候分配时间戳和生成水位线
    > 源函数会发出一条记录，每个发出的记录都可以附加一个时间戳，水位线可以作为特殊记录在任何时间点发出
  * 周期分配器(periodic assigner)
    > 用户自定义函数AssignerWithPeriodicWatermarks，可以用来从每条记录提取时间戳，并周期性的响应获取当前水位线的查询请求
    > 提取出来的时间戳会附加到各自的记录上，查询得到的水位线会注入数据流中
    > 默认周期是200毫秒，可以使用ExecutionConfig.setAutoWatermarkInterval()方法进行设置
  * 定点分配器(punctuated assigner)
    > 用户自定义函数AssignerWithPunctuatedWartermarks，可用于需要根据特殊输入记录生成水位线的情况 
    > 没有时间周期规律，可打断的生成watermark
    > 不会强制每条记录都提取一个时间戳
```