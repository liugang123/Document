
- #### 硬件效率
```
《1》计算机同时做几件事，不仅因为计算机的运算能力强大，
还有计算机的运行速度与它的存储和通信子系统速度的差距太大，
大量的时间花费在磁盘I/O、网络通信或数据库访问上
《2》计算机加入了一层读写尽可能接近处理器的高速缓存（cache）作为内存和处理器之间的缓存
将运算需要的数据复制到缓存中，让运算快速进行
当运算结束后在从缓存同步回内存中
《3》多处理器每个处理器都有自己的高速缓存，而它们共享同一主存，可能导致缓存数据的不一致性
为确保缓存的一致性，各个处理器都遵循规定的协议来操作数据（MSI、MESI、MOSI等）
```

- #### java内存模型
```
《1》jvm规范定义来一种java内存模型（JMM），屏蔽各种硬件和操作系统的内存访问差异，使各个平台达到内存访问数据的一致
《2》JMM主要目标是定义程序中各个变量的访问规则，即虚拟机将变量存储到内存和取出变量这样的底层细节
变量包括实例字段、静态字段和构造数组对象的元素，
不包括局部变量与方法参数，这些都是线程私有的
《3》JMM规定所有的变量都存储在主内存，每个线程都有自己的工作内存，
线程工作内存拷贝了要使用的变量主内存的副本，线程对变量的操作都必须在工作内存中进行，而不能直接读取主内存的变量
不同的线程之间也无法直接访问对方工作内存的变量，线程间变量的传递都需要经过主内存
```
```
graph LR
java线程1--工作内存1-->主内存
java线程2--工作内存2-->主内存
java线程3--工作内存3-->主内存
```
```
主内存主要对应Java堆中的对象时例数据部分，对应与物理硬盘的内存
工作内存对应于虚拟机栈中的部分内容
```
- #### 内存交互操作
```
一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存
JMM定义了8种操作来实现主内存和工作内存之间的交互协议
```

操作 | 区域|说明 
---|---|---
lock(锁定) | 主内存 |将变量标志为线程独占状态
unlock(解锁) |主内存| 将处于锁定状态的变量释放
read(读取) | 主内存 |将变量的值从主内存传输到线程的工作内存中
load(载入)|工作内存|将read的值从主内存中拷贝到工作内存的副本 
use(使用) | 工作内存 |将工作内存变量的值传递给执行引擎
assign(赋值) |工作内存|将执行引擎的值赋值给工作内存 
store(存储) | 工作内存 |将工作内存的变量值传送到主内存中
write(写入) |主内存| 将store操作的变量值放入主内存中

```
8中操作满足的规则
《1》一个变量同一时刻只能被一个线程lock，可以对变量锁定多次
《2》一个变量被lock后，将清空工作内存中此变量的值
```

- #### volatile型变量
```
《1》volatile是虚拟机提供的最轻量级的同步机制
《2》保证对所有线程的看见性，即一条线程修改来变量值，新值对于其他线程可以立即得知
虽然普通变量也是通过主内存来完成数据刷新的，但是不能做到“及时刷新”
《3》java里的运算并非都是原子操作，导致volatile变量在并发下一样不安全
在不符合以下两条规则的运算场景，仍然需要通过加锁
  * 运算经过并不依赖变量的当前值，或能够保证只有单一的线程修改变量值
  * 变量不需要与其他的状态变量共同参与不变的约束
《4》使用volatile的变量可以禁止指令重排序优化,确保程序代码的执行顺序
```
```
public class Singleton{
    public static volatile Singleton instance;
    private Singleton(){
        
    }
    public static Singleton getInstance(){
        if(instance==null){
            synchronized(Singleton.class){
                if(intance==null){
                    instance = new Singleton();
                }
            }
        }
    }
}
```
- JMM特性
```
java内存模型围绕并发过程过程中如何处理原子性、可见性和有序性3个特征建立
* 原子性：jmm直接保证的原子性变量操作（read、load、sign、use、store、write），基本类型的访问读写具备原子性（synchronized关键字）
* 可见性：指当一个线程修改了共享变量的值，其他线程能够立即得知这个变量的修改（volatile、synchronzied关键字）
* 有序性：在同一线程，所有操作都是有序的，
         在一个线程观察另一个线程，所有操作都是无序的（volatile和synchronzied关键字）
```

- 先行发生原则
```
用来判断数据是否存在竞争、线程是否安全的主要依据
不符合“先行发生”的以下规则就无法保证“有序性”
《1》程序次序规则：在一个线程内，按照程序代码顺序执行
《2》管程锁定规定：一个unlock操作先行发生于后面对同一个锁的lock操作
《3》Volatile变量规则：对一个Volatile变量的写操作先行发生于后面对这个变量的读操作
《4》线程启动规则：Thread对象的start方法先行发生于此线程的每个动作
《5》线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测
《6》线程中断规则：对线程interrup方法的调用先行发生于被中断线程的代码检测到中断时间的发生
《7》对象终结规则：一个对象的初始化完成先行发生于它的finalize方法执行
《8》传递性：操作啊a先行发生于操作b，操作b先行发生操作c，a先行发生于c
```
- #### 线程的实现
```
线程实现的3种方式：内核线程实现、用户线程实现和轻量级进程混合实现
《1》内核线程的实现
     * 直接由操作系统内核支持的线程，由内核完成线程的切换，
     * 内核通过调度器对线程调度，并负责将线程任务映射到各个处理器
     *一般不会直接使用内核线程，而是实现内核线程的接口（轻量级进程），轻量级进程和内核线程是1:1的关系
     * 系统代价较高，需要在用户态和内核态来回切换，同时要消耗内核资源，系统支持的轻量级进程是有限的
《2》用户线程实现
     * 完全建立在用户空间的线程上，系统内核不能感知线程的存在
     * 可以不用切换到系统的内核态
《3》用户线程和轻量级进程混合实现
     * 即存在用户线程也存在轻量级进程
     * 用户线程完全建立在用户空间中，轻量级进程作为用户线程和内核线程的桥梁，
       使用内核提供的线程调度给你及处理器映射
```
- #### 线程调度
```
指系统为线程分配处理器使用权的过程，调度方式主要有两种:
《1》协同式线程调度：
     * 线程的执行时间由线程本身来控制，线程执行完成后，主动通知系统切换到另一个线程
     * 线程执行时间不可控制，程序可能会一直阻塞，导致整个系统崩溃
《2》抢占式线程调度：
     * 每个线程将由系统来分配执行时间，线程的切换不由线程本身决定
       线程的阻塞不会引起整个进程的阻塞    
```
- #### java线程状态
```
java语言定义了5种线程状态，任何时间点，一个线程只能有且只有其中一种状态
《1》新建(New):创建后尚未启动的线程
《2》运行(Runable):包含Running和Ready状态，线程可能正在执行，也可能等待CPU分配执行时间
《3》无限期等待(Waiting):等待其他线程显式的唤醒，不会被分配CPU执行时间(Object.wait()、Thread.Sleep())
《4》限期等待(TimeWating):无需等待其他线程显式唤醒，在一定时间有系统主动唤醒，也不会分配CPU执行时间（Thread.Sleep()）
《5》阻塞(Blocked):等待获取一个“排他锁”，这个事件在另一个线程放弃锁时触发，
     进入同步区域，线程进入阻塞状态
《6》结束(Terminated):线程已结束执行，进入结束状态     
```

```
graph LR
new--"strat()" -->Running 
Running --"wait()"-->Waiting
Waiting --"notify()"-->Running
Running -- "synchronized" --> Blocked
Blocked -- "synchronized" --> Running
Running -- "sleep()" --> TimedWaiting
Running -- "run()" --> Terminated
```
- #### 线程安全
```

```