- #### AOP概念
```
1.AOP全称Aspect-Oriented Programming，面向切面编程，AOP引入Aspect的概念，用来以模块化的形式对系统中的横切关注点进行封装
2.AOP需要某种语言以帮助实现相应的概念实体，称这些实现AOP的语言为AOL，即Aspect-Oriented Language
3.静态AOP
  * 第一代AOP，以AspetJ为代表，特点是相应的横切关注点以Aspect形式实现之后，
    会通过特定的编译器，将实现后的Aspect编译并织入到系统的静态类中
  * 优点：Aspect直接以字节码的形式编译到Java类中，java虚拟机可以像通常一样加载java类运行，不会对整个系统的运行造成任何的性能损失
  * 缺点：灵活性不够，如果横切关注点需要改变织入到系统的位置，就需要重新修改Aspect定义文件，然后使用编译器重新编译Aspect并重新织入到系统中
4.动态AOP
  * 第二代AOP，通过java语言提供的各种动态特性来实现Aspect织入到当前系统中，如JBoss AOP、Spring AOP等
  * 在AspectJ融合了AspectWerkz框架之后，也引入了动态织入的行为，从而成为Java界唯一一个同时支持动态和静态AOP特性的AOP实现产品
  * 优点：大都使用java语言实现，AOP的各种概念实体全部都是普通的java类，很容易开发和集成
  * 与静态AOP最大的不同是，AOP的织入过程在系统运行开始之后进行，而不是预先编译到系统类中
  * 缺点：动态AOP的实现大都在类加载或者系统运行期间，采用对系统字节码进行操作的方式来完成AspectJ到系统的织入，难免会造成一定的运行时性能损失
```

- #### Java平台AOP实现机制
```
1.动态代理
 * JDK1.3之后，引入动态代理(Dynamic Proxy)机制，可以在运行期间，为相应的接口动态生成相应的代理对象
 * 可以将横切关注点逻辑封装到动态代理的InvocationHandler中，然后在系统运行期间，根据横切关注点需要织入的模块位置，将横切逻辑织入到相应的代理类中
 * 所有需要织入横切关注点逻辑的模块类都得实现相应得接口，因为动态代理机制只针对接口有效
 * Spring AOP默认情况下采用动态代理机制实现AOP功能
2.动态字节码增强
 * 可以为需要织入横切逻辑的模块类在运行期间，通过字节码增强技术，为这些系统模块类生成相应的子类，而将横切逻辑加到这些子类中，从而达到将横切逻辑织入系统的目的
 * 使用动态字节码增强技术，即使模块类没有实现相应的接口，依然可以对其进行扩展，而不用像动态代理那样受限于接口
 * Spring AOP在无法采用动态代理机制进行AOP功能扩展的时候，会使用CGLIB库的动态字节码增强支持来实现AOP的功能扩展
3.自定义类加载器
 * 可以通过自定义类加载器的方式完成横切逻辑到系统的织入，功能与之前的几种方式相比强大很多
 * JBoss AOP和已经并入AspectJ项目的AspectWerkz框架都是采用自定义类加载器的实现方式
```

- #### AOP术语
```
1.Joinpoint
 * 在系统运行之前，AOP的功能模块都需要织入到OOP的功能模块中，要进行这种织入过程，需要知道在系统的那些执行点上进行织入操作，
   这些将要在其之上进行织入操作的系统执行点就是Joinpoint
 * 常见的joinpoint类型
   - 方法调用（Method Call）
     在某个方法被调用的时候所处的程序执行点
   - 方法调用执行（Method Call execution）
     在某个方法内部执行开始时点
   - 构造方法调用（Constructor Call）
     程序执行过程中某个对象调用其构造方法进行初始化的时点
   - 构造方法执行（Constructor Call Execution）
     某个对象构造方法内部执行的开始时点
   - 字段设置（Field Set）
     对象的某个属性通过setter方法被设置或者直接被设置的时点
   - 字段获取（Field Get）
     某个对象相应属性被访问的时点
   - 异常处理执行（Exception Handler Execution）
     对应程序执行过程中，在某些类型异常抛出后，对应的异常处理逻辑执行的时点
   - 类初始化（Class Initialization）
     类中某些静态类型或者静态块的初始化时点
2.Pointcut
  * Pointcut概念代表的是Joinpoint的表述方式，将横切逻辑织入当前系统的过程中，需要参照Pointcut规定的Joinpoint信息，才能知道往系统的那些Joinpoint上织入横切逻辑
  * Pointcut的表述方式
    - 直接指定Joinpoint所在方法名称
      这种形式的Pointcut表述方式比较简单，功能单一，通常只限于支持方法级别Joinpoint的AOP框架
    - 正则表达式
      比较普遍的Pointcut表达方式，可以充分利用正则表达式的强大功能，来归纳表述需要符合某种条件的多组Joinpoint
    - 使用特定的Pointcut表述语言
      > 较为强大的表述Pointcut的方式，灵活性很好，具体实现复杂，需要设计该表述语言的语法，实现相应的解释器等工作
      > Aspect使用这种方式来指定Pointcut，它提供了一种类似于正则表达式的针对Pointcut的表述语言
      > Spring 2.0之后，借助于AspectJ的Pointcut表述语言解释器，同样也支持使用AspectJ的Pointcut表述语言来指定Pointcut
3.Advice
  * Advice是单一横切关注点逻辑的载体。它代表将会织入到Joinpoint的横切逻辑，如果将Aspect比作OOP中的Class，那么Advice就相当于Class中的Method
  * 按照Advice在Joinpoint位置执行时机的差异或者完成功能的不同，Advice可以分成多种具体形式
    - Before Advice
      > 在Joinpoint指定位置之前执行的Advice类型
      > 如果当前Before Advice将被织入到方法执行类型的Joinpoint，那么这个Before Advice就会先于方法执行而执行
    - After Advice
      > 在相应连接点之后执行的Advice类型，该类型的Advice还可以细分为以下三种
      > After returning Advice
        只有在当前Joinpoint处执行流程正常完成后，After retuning Advice才会执行，如方法执行正常返回而没有抛出异常
      > After throwing Advice（Throws After）
        只有在当前Joinpoint执行过程中抛出异常的情况下，才会执行，如某个方法执行类型的Joinpoint抛出异常而没有正常返回
      > After Advice（after finally Advice）
        该类型不管Joinpoint处执行流程是正常终止还是抛出异常都会执行，就像Java中的finally块一样
    - Around Advice
      Around Advice对附件其上的Joinpoint进行包裹，可以在Joinpoint之前和之后都指定相应的逻辑，甚至于中断或者忽略Joinpoint处原来程序流程的处理
    - Introduction
      > 于之前的几种Advice类型不同，Introduction不是根据横切逻辑在Joinpoint处的执行时机来区分的，而是根据它可以完成的功能而区别于其他Advice类型
      > Introduction类型的Advice可以为原有的对象添加新的特性或者行为
      > AspectJ的Introduction采用静态织入的形式，在使用对象时，逻辑已经是编译织入完成的，理论上，AspectJ提供的Introduction类型的Advice，
        在现有的Java平台上的AOP实现性能最好
4.Aspect
  * Aspect是对系统中的横切关注点逻辑进行模块化封装的AOP概念实体
  * Aspect可以包含多个Pointcut以及相关Advice定义
5.织入和织入器
  * 织入（Weaving）过程就是连接AOP和OOP的桥梁，只有经过织入过程之后，已Aspect模块化的横切关注点才会集成到OOP的现存系统中，
    完成织入过程的组件成为织入器（Weaver）
  * AspectJ有专门的编译器来完成织入操作，即ajc，所以ajc就是AspectJ完成织入的织入器
  * Spring AOP使用一组类来完成最终的织入操作，ProxyFactory类就是Spring AOP中最通用的织入器
6.目标对象（Target Object）
  符合Pointcut所指定的条件，将在织入过程中被织入横切逻辑的对象，就是目标对象
```

- #### Spring AOP实现机制
```

```