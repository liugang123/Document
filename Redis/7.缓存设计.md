- #### 单线程架构
```
1.Redis使用了单线程架构和I/O多路复用模型来实现高性能的内存数据库服务，
  每次客户端调用都经历发送命令、命令排队、执行命令、返回结果4个过程
2.单线程架构性能还比较快的原因：
 * 纯内存访问，Redis将所有数据放在内存中，内存的响应时长大约为100纳秒，这是redis达到每秒万级别访问的重要基础
 * 非阻塞I/O，Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型epoll中的连接、读写、关闭都转换为事件，
   不会在网络I/O上浪费过多的时间
 * 单线程可以简化数据结构和算法，避免了线程切换和竟态产生的消耗
```

- #### 穿透优化
```
1.缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中缓存
2.造成缓存穿透的基本原因有两个：
  * 自身业务代码或者数据出现问题
  * 恶意攻击、爬虫等造成大量空命中
```

- **缓存空对象和布隆过滤器方案对比**

解决缓存穿透 | 适用场景 | 维护成本
---|---|---
缓存空对象 | 数据命中不高<br/>数据频繁变化实时性不高 | 代码维护简单<br/>需要过多的缓存空间<br/>数据不一致
布隆过滤器 | 数据命中不高<br/>数据相对固定实时性低 | 代码维护复杂<br/>缓存空间占用少


- #### 雪崩优化
```
1.由于缓存承受着大量请求，有效的保护存储层，但如果缓存由于某些原因不能提供服务，所有的请求都会达到存储层，
  存储层的调用会暴增，造成存储层级联宕机的情况
2.缓存雪崩stampeding herd，指的是缓存层宕机后，流量会像奔跑的野牛，打向后端服务
3.预发和解决缓存雪崩，可以以下方法：
  * 保证缓存层服务高可用性
  * 依赖隔离组件为后端限流并降级
  * 提前演练
```

- #### 热点key重建优化
```
1.当前key是一个热点，并发量非常大，重建缓存不能在短时间完成，可能是一个复杂SQL、多次IO、多个依赖等，
  在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，设置可能会让应用崩溃
```

- **两种热点key的解决方法**

解决方案 | 优点 | 缺点
---|---|---
简单分布式锁 | 思路简单<br/>保证一致性| 代码复杂度增大<br/>存在死锁的风险<br/>存在线程池阻塞的风险
"永远不过期" | 基本杜绝热点key问题| 不保证一致性<br/>逻辑过期时间增加代码维护成本和内存成本

