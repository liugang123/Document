- #### 字符串(string)
```
1.Redis构建了一种简单动态字符串(simple dynamic string)的抽象类型，作为默认字符串的表示
2.c字符串只作为字符串字面量用在无需对字符串修改的地方
3.在Redis中，包含字符串键值对在底层都是由SDS实现的 
  SET msg "hello word"
* 键是一个字符串对象，对象底层实现是一个保存"msg"的SDS
* 值是一个字符串对象，对象底层实现是一个保存"hello world"的SDS
```

- #### SDS定义
```
Resdis用结构体表示SDS
  struct sdshdr {
    // 记录buf数组中已使用的字节数量，等于SDS所保存字符串的长度
    int len;
    // 记录buf数组中未使用字节的数量
    int free;
    // 字节数组，用于保存字符串
    char buf[];
  }
1.SDS遵循c字符串以空字符串结尾的惯例，空字符串占的1字节空间不计算在len属性里，并为空字符串分配额外的1字节空间，都是SDS函数自动完成的  
2.通过使用SDS，Redis将获取字符串长度所需的复杂度从O(n)降低到了O(1)
3.SDS的空间分配策略杜绝缓冲区溢出的可能性
4.空间预分配策略用于优化字符串的增长操作，SDS连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次
5.惰性空间释放用于优化字符串缩短操作，SDS字符串发生缩短操作时，Redis并不立即使用内存重分配回收缩短多出的字节，
  而是使用free属性将字节数量记录下来，等待将来使用
6.SDS是二机制安全的，内容长度保存在len属性中，避免空字符串可能会引起的错误，因此，Redis不仅可以保存文本数据还可以保存任意的二进制文件
7.通过遵循c字符串以空字符结尾的惯例，SDS可以复用部分c库函数，避免不必要的代码重写
```

- **c字符串和SDS比较**

c字符串 | SDS
---|---
获取字符串长度的复杂度为O(n) | 获取字符串长度的复杂度为O(1)
API是不安全的，可能会造成缓冲区溢出 | API是安全的，不会造成缓冲区溢出
修改字符串n次必然需要执行n次内存重分配 | 修改字符串n次最多需要执行n次内存重分配
只能保存文本数据  | 可以保存文本或者二进制数据
可以使用c库中的所有函数 | 可以使用c库中的部分函数

- #### 双端链表(list)
```
1.链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活的调整链表的长度
2.链表根据指针域的不同，可以分为单向链表、双向链表、循环链表
  循环链表的第一个节点prev的指针指向最后一个节点，最后一个节点的next指针指向第一个节点
3.Redis也构建了自己的链表实现，链表为双向无环链表
* 链表节点表示
typedef struct listNode {
    // 前置节点
    struct listNode *prev;
    // 后置节点
    struct listNode *next;
    // 节点值
    void *value;
}listNode
* 链表表示
typedef struct list {
    // 表头节点
    listNode *head;
    // 表尾节点
    listNode *tail;
    // 链表包含的节点数量
    unsigned long len;
    // 节点值复制函数
    void *(*dup)(void *ptr);
    // 节点值释放函数
    void (*free)(void *ptr);
    // 节点值对比函数
    int (*match)(void *ptr,void *key);
}
4.Redis链表实现的特性:
* 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度为O(1) 
* 无环：表头节点prev和表尾节点的next指针都指向null，对链表的访问以null为终点
* 带表头指针和表尾指针：通过list结构的head指针和tail指针获取链表的表头节点和表尾节点的复杂度为O(1)
* 带链表长度计数器：使用list结构的len属性获取链表节点数量的复杂度为O(1)
* 多态：链表节点使用void*指针保存节点值，可以保存各种不同类型的值
```

- #### 字典(dict)
```
1.字典用来保存键值对的抽象数据结构，又称为符号表、关联数组、映射
2.Redis构建了自己的字典实现，并且使用字典作为底层实现，对数据库的增、删、查、改都是构建在对字典的操作上
3.Redis字典使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，每个哈希表节点就保存了字典中的一个键值对
4.哈希表结构定义：
typedef struct dictht {
    // 哈希表数组
    dictEntry **table;
    // 哈希表大小
    unsigned long size;
    // 哈希表大小掩码，用于计算索引值，总是等于size-1
    unsigned long sizemask;
    // 哈希表已有节点的数量
    unsigned long used;
} dictht;
sizemask属性和哈希值一起决定一个键应该被放到table数组的那个索引上面
哈希表节点结构定义：
typedef struct dictEntry {
    // 键
    void *key;
    // 值
    union {
        void *val;
        uint64 _tu64;
        int64 _ts64;
    } v;
    // 指向下一个哈希表节点，形成链表
    struct dictEntry *next;
} dictEntry;
next属性指向另一个哈希表节点的指针，可以将多个哈希值(索引值)相同的键值对连接在一起，来解决键冲突的问题
5.字典结构表示
typedef struct dict {
    // 类型特定函数
    dictType *type;
    // 私有函数
    void *privdate;
    // 哈希表
    dictht ht[2];
    // rehash索引，当rehash不在进行时，值为-1
    in trehashidx;
} dict;
type属性和privdata属性针对不同类型的键值对，为创建多态字典设计：
* type属性是指向dictType结构的指针，每个dictType结构保存了一组用于操作特定类型键值对的函数
* privdata属性保存了需要传递给特定类型函数的可选参数
ht属性是包含两个哈希表元素的数组，字典只使用ht[0]哈希表，ht[1]哈希表在对ht[0]就行rehash时使用，负责值为-1
6.哈希算法
当有新的键值对添加到字典时，redis先根据键计算出哈希值和索引值，再将包含新键值对的哈希节点放到哈希表数组指定的索引上
* 计算哈希值：
 // 使用字典设置的哈希函数，计算key的哈希值
 hash = dict->type->hashFunction(key);
* 计算索引值：
 // 使用哈希表的sizemask属性和哈希值，计算索引值
 index = hash & dict->ht[x].sizemask;
7.键冲突
* 当两个或多个数量的键被分配到了一个哈希数组的同一个索引上，就发生了键冲突
* Redis哈希表使用链地址法解决键冲突，被分配到同一个索引上的多个节点可以用单向链表连接起来，
   并且新节点总是被添加到链表的表头位置，排在已有节点前面
8.哈希表的扩容和收缩
* 哈希表的键值对会逐渐增多或减少，为了让负载因子维持在一个合理的范围内，
  哈希表需要通过执行rehash(重新散列)操作来进行收缩和扩容
* 根据bgsave或bgrewriteaof命令是否执行，计算负载因子的值决定哈希表是否进行扩容，扩容操作分别在>=1或>=5时执行
* 负载因子的计算：
  // 负载因子 = 哈希表已保存节点数量 / 哈希表大小
  load_factor = ht[0].used / ht[0].size
9.渐进rehash
* 为了避免rehash对服务器性能影响，重新散列是分多次、渐进式的完成的
* 当一次rehash操作完成后，rehashidx属性的值加1，所有键值对都完成了重新散列，rehashidx属性被设置为-1
* 在rehash期间，字典的删除、查找、更新操作会在两个哈希表上进行，
  新增操作只在ht[1]上进行，保证ht[0]包含的键值对数量只减不增
```

- #### 跳跃表(skiplist)
```
* 跳跃表(skiplist)一种有序的数据结构，通过在每个节点维持多个指向其他节点的指针，从而达到快速访问节点的目的
* 跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批处理节点
* 跳跃表的效率和平衡树差不多，并且实现比平衡树要简单，可以使用跳跃表来代替平衡树
* Redis使用跳跃表来作为有序集合键的底层实现
```

- #### 跳跃表实现
```
跳跃表节点结构定义：
typedef struct zskiplistNode {
    // 层
    struct zskiplistLevel {
        // 前进指针
        struct zskiplistNode *forward;
        // 跨度
        unsigned int span;
    } level[];
    // 后退指针
    struct zskiplistNode *backward;
    // 分值
    double score;
    // 成员对象
    robj *obj;
    
} zskiplistNode;
1.层：跳跃表节点的level数组可以包含多个元素，每个节点包含指向其他节点的指针
  通过层可以加快访问其他节点的速度，层的数量越多，访问其他节点的速度越快
2.前进指针：每个层都有一个指向表尾方向的前进指针，用来从表头指向表尾方向访问节点
3.跨度：
  * 两个节点的跨度越大，相隔的越远
  * 指向null的所有前进指针的跨度都为0
  * 在查找某个节点的过程中，将沿途访问过的所有层跨度累计起来，得到的结果就是目标节点在跳跃表中的排位
4.后退指针：用于从表尾方向访问节点，每次只能退回至前一个节点
5.分值和成员
  * 节点的分值为double类型，所有节点都按分值从小到大排序
  * 节点成员对象是一个指针，指向字符串对象
  * 同一个跳跃表中，各个节点的成员对象必须唯一，多个节点的分值可以相同，
    分值相同的节点按照成员对象在字典序中的大小来进行排序
跳跃表结构定义
typedef struct zskiplist {
    // 表头节点和表尾节点
    struct skiplistNode *header, *tail;
    // 表中节点的数量
    unsigned long length;
    // 表中层数最大的节点的层数
    int level
} zskiplist;
* 通过表头、表尾指针程序定位表头、表尾节点的复杂度为O(1)
* 通过length属性获取跳跃表长度的复杂度为O(1)
* 通过level属性获取跳跃表层高最大节点的层数量的复杂度为O(1)
```

- #### 整数集合(intset)
```
1.整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且元素量不多时，Redis使用整数集合作为集合键的底层实现
2.整数集合是Redis用于保存整数值的集合抽象数据结构，并且保证集合中不会出现重复元素
3.整数集合的结构体表示：
typedef struct inset {
    // 编码方式
    unit32_t encoding;
    // 集合包含的元素数量
    unit_32_t length;
    // 保存元素的数组
    int8_t contents[];
} intset;
* contents数组的每个数组项都表示整数集合中一个元素，数据项按从大到小有序排列，并且数组不包含任何重复项
* length属性表示整数集合的元素数量，即contents数组的长度
* encoding属性决定contents数组的数据类型
4.升级
如果新添加的元素比整数集合现有的所有元素的类型都要长，整数集合需要进行升级，才能将新元素添加到集合中
5.降级
整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态
```

- #### 压缩列表(ziplist)
```
1.压缩列表是一种为节约内存开发的顺序型数据结构，由一序列特殊编码的连续内存块组成的顺序型(sequential)数据结构，
  一个压缩列表可以包含任意多个节点(entry)，每个节点可以保存一个字节数组或者一个整数值
2.当一个列表键只包含少量数据项，并且每个项要么是小整数值、要么是段字符串，redis就使用压缩列表作为列表键的底层实现
3.压缩列表的构成
  [zlbytes|zltail|zllen|entry1|entry2|...|entryn|zlend]
* zlbytes：记录整个压缩列表占用的内存字节数
* zltail：记录压缩列表表尾节点距离压缩列表的起始地址有多少字节
* zllen：记录压缩列表包含的节点数量
* entry：压缩列表包含的各个节点，节点的长度由节点的内容决定
* zlend：特殊值0xFF用于标记压缩列表的末端
4.压缩列表节点的构成
  [previous_entry_length|encoding|content]
* previous_entry_length属性：以字节为单位，记录压缩列表前一个节点的长度，可以根据当前节点的起始地址快速计算出上一个节点的起始位置
* encoding属性：记录了节点的content属性所保存的数据类型及其长度
* content属性：负责保存节点的值
5.连锁更新
添加或删除节点可能会引起压缩列表的连锁更新操作，但出现的机率并不高
```

