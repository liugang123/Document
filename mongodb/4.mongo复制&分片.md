- #### 复制
```
1.副本集是一组服务器，其中有一个主服务器(primary)，用于处理客户端请求，还有多个备份服务器(secondary)，用于保存主服务器的数据副本
2.客户端不能在备份节点上执行写操作
3.默认情况，客户端不能从备份节点读取数据，在备份节点显示的执行setSlaveOK之后，客户端可以从备份节点中读取数据
4.如果主服务器崩溃了，备份服务器会自动将其中一个成员升级为新的主服务器
```

- #### 数据同步
```
1.mongoDB的复制功能是使用操作日志oplog实现的，操作日志包含了主节点的每一次写操作
2.oplog是主节点的local数据库中的一个固定集合，备份节点通过查询这个集合可以知道需要进行复制的操作
3.如果主节点的数据和从节点的数据发生冲突，从节点会切换到回滚状态进行回滚
4.如果要回滚的数据量大于300MB，或者回滚30分钟以上的操作，回滚就会失败，对于回滚失败的节点必须重新同步
```

- #### 分片
```
1.分片也称分区，是指将数据拆分，将其分散存放在不同的机器上的过程
2.MongoDB支持自动分片，可以自动处理数据在分片上的分布，也可以添加删除分片，同时，使数据库架构对应用程序是不可见的，就像使用一个单机的mongoDB服务器一样
3.可以将数据子集分散在服务器集群中，每个分片维护着一个数据集合的子集
4.对于集合分片时，要选择一个片键，片键是集合中的一个键(字段)，MongoDB根据这个键拆分数据
5.只有被索引过的键才能够作为片键
6.定向查询：包含片键的查询能够直接被发送到目标分片或者是集群分片的一个子集
7.分散聚合查询：查询必须被发送到所有的分片，然后将各个分片的查询结果聚集起来
8.分片的作用：
* 增加可用的RAM
* 增加可用的磁盘空间
* 减轻单台服务器的负载
* 处理单个mongod无法承受的吞吐量
```

- 集群分片架构
```
graph TD
A[客户端] -->B[Mongos]
B -->C[mongod1]
B -->D[mongod2]
B -->E[mongod3]
```

- #### 配置分片
```
1.mongoDB不会自动对数据进行拆分，需要明确告知数据库和集合，数据才会被分片
 // 对music数据库中的集合进行数据分片
 >db.enableSharding("music")
 // 对集合artists按照name键进行分片
 >db.shardCollection("music.artists",{"name":1})
2.块表示包含的文档范围，mongons会记录每个块中插入了多少数据，一旦达到某个阀值，就会对块进行拆分
3.块拆分只需要改变块的元数据信息即可，而无需进行数据的移动
4.均衡器负责数据的迁移，会周期性的检查分片间是否存在不均衡，如果存在，就会进行块的迁移
```

- #### 选择分片
```
拆分数据常用的数据分发方式有三种：
1.升序片键
* 随着时间稳定增长的字段，如"date"字段或ObjectId
* 所有的写请求都会被路由到一个分片，这种模式会导致MongoDB的数据均衡处理变得困难，数据迁移会比较频繁
2.随机分发的片键
* 随机分发的片键可以是用户名、UDID、MD5散列值或者文档中没有规律的键
* 写入数据是随机分发的，各分片增长的速度应大致相同，数据会比较均衡的分布在不同的块中，减少需要进行迁移的次数
3.基于位置的片键
* 可以是用户的IP、经纬度或地址，可以比较方便的将用户数据与相应的用户以及相关的数据保存在一起
* 如果希望将特定范围的块出现在特定的分片中，可以为分片添加tag，然后为块指定相应的tag
```

- #### 片键策略
```
1.散列片键
* 散列片键可使其他任何键随机分发，如果打算在大量查询中使用升序键，同时又希望写入的数据随机分发的话，散列片键是很好的选择
* 散列片键不能进行目标指定范围查询
* 创建散列片键，首先要创建散列索引
  >db.users.ensureIndex({"username":"hashed"})
  // 对集合进行分片
  >sh.shardCollection("app,users",{"username":"hashed"})
2.GridFS的散列片键
3.流水策略
4.多热点
```