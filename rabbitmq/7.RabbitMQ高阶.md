- #### 存储机制
```
(1)不管是持久化的消息还是非持久化的消息都可以被写入磁盘：
   * 持久化的消息在到达队列时就被写入磁盘，并且如果可以，持久化的消息也会在内存中保存一份备份，可以提高一定的性能，
     在内存吃紧的时候就会从内存中清除
   * 非持久化的消息一般只保存在内存中，在内存吃紧的时候会被换入到磁盘中，已节省内存空间
   两种类型消息的落盘处理都在RabbitMQ的持久层中完成
(2)持久层是一个逻辑概念，实际包含两个部分：队列索引(rabbitmq_queue_index)和消息存储(rabbitmq_msg_store)
  * rabbitmq_queue_index：负责维护队列中落盘消息的信息，包括消息的存储地点、是否已被交付消费者、是否已被消费者ack等
    每个队列都有与之对应的rabbitmq_queue_index
  * rabbitmq_msg_store：以键值对的形式存储消息，被所有队列共享，在每个节点中有且只有一个
    rabbitmq_msg_store具体分为msg_store_transient和msg_store_persistent
    msg_store_persistent负责持久化消息的持久化，重启后消息不会丢失
    msg_store_trainsient负责非持久化消息的持久化，重启后消息会丢失
(3)消息(包括消息体、属性和headers)可以直接存储在rabbitmq_queue_index中，也可以保存在rabbitmq_store中
   默认在$RABBITMQ_HOME/var/lib/mnesia/rabbit@$HOSTNAME/路径下包含queues、msg_store_presistent、msg_store_transient这3个文件夹，
   分别存储对应的消息
(4)最佳的配备是较小的消息存储在rabbitmq_queue_index中，而较大的消息存储在rabbit_msg_store中
   消息的大小可以通过queue_index_embed_below来配置，默认大小为4096，单位为B
   当一个消息大小小于设定的大小阈值时就可以存储在rabbit_queue_index中，这样可以得到性能上的优化
(5)rabbitmq_queue_index中以顺序的段文件进行存储，后缀为".idx"，每个段文件中包含固定的SEGMENT_ENTRY_COUNT条记录，默认值为16384
   每个rabbit_queue_index从磁盘中读取消息时至少维护一个段文件，设置queue_index_embed_msgs_below值的时候要格外谨慎，
   一点点增大可能会引起内存爆炸式的增长
(6)经过rabbit_msg_store处理的所有消息都会以追加的方式写入文件中，当一个文件的大小超过指定的限制后，
   关闭这个文件在创建一个新的文件以供新的消息写入
   文件名以".rdq"为后缀，从0开始进行累加，文件名最小的文件也是最老的文件
   在进行消息的存储时，RabbitMQ会在ETS表中记录消息在文件中的位置映射和文件的相关信息
   在读取消息时，先根据消息的ID找到对应存储的文件，如果文件并不存在且未被锁住，则直接打开，从指定位置读取消息的内容
   如果文件不存在或被锁住了，则发送请求由rabbit_msg_store进行处理
```

- #### 队列结构
```
(1)通常队列由rabbit_amqqueue_process和backing_queue两部分组成
   * rabbit_qmqqueue_process负责协议相关的消息处理，即接收生产者发布的消息、向消费者交付消息、处理消息的确认(生产端的confirm和消费者的ack)等
   * backing_queue是消息存储的具体形式和引擎，并向rabbit_amqqueue_process提供相关的接口以供调用
(2)如果消息投递的目标队列是空的，并且有消费者订阅了队列，那么消息会直接发送给消费者，不会进过队列这一步
   当消息无法直接投递给消费者时，需要暂时将消息存入队列，以便重新投递
   消息存入队列后，不是固定不变的，它会随系统的负载在队列中不断的流动，消息的状态会不断的发生变化
(3)RabbitMQ中队列消息可能会处于4种状态
  * alpha：消息内容(包括消息体、属性和headers)和消息索引都存储在内存中
  * beta：消息内容保存在磁盘中，消息索引保存在内存中
  * gamma：消息内容保存在磁盘中，消息索引在磁盘和内存中都有
  * delta：消息内容和索引都在磁盘中
  对于持久化消息，消息内容和消息索引都必须先保存在磁盘中，才会处于上述状态中的一种，
  而gamma状态的消息是只有持久化的消息才会有的状态
(4)RabbitMQ在运行时会根据统计的消息传送速度定期计算一个当前内存中能够保存的最大消息数量(target_ram_count)，如果alpha状态的消息数量大于此值，
   就会引起消息的状态转换，多余的消息会转移到beta状态、gamma状态或者delta状态，
   区分4种消息状态主要作用是满足不同内存和CPU需求
   * alpha状态：最耗内存，但很少消耗CPU
   * delta状态：基本不消耗内存，但是需要消耗更多的CPU和磁盘I/O操作
     delta状态需要执行至少两次I/O操作才能读取消息，一次读取消息索引(从rabbit_queue_index中)，一次是读取消息内容(从rabbit_msg_store中)
   * beta和gamma状态都只需要一次I/O操作就可以读取到消息(从rabbit_msg_store中)     
(5)对于普通的没有优先级和镜像的队列，backing_queue的默认实现是rabbit_variable_queue，其内部通过5个子队列Q1，Q2，Delta，Q3和Q4来体现消息的各个状态
  * Q1，Q4只包含alpha状态的消息
  * Q2，Q3包好beta和gamma状态的消息
  * Delta只包好delta状态的消息
  * 一般情况，消息按照Q1->Q2->Detla->Q3->Q4的顺序步骤进行流动，但并不是每调消息都一定会经历所有的消息状态，这取决于当前系统的负载状态
  * 从Q1到Q4基本经历内存到磁盘，在有磁盘到内存这样一个过程，如此可以在队列负载很高的情况下，能够通过将一部分消息由磁盘保存来节省内存空间，
    而在负载降低时，这部分消息又渐渐回到内存被消费者获取，使整个队列具有很好的弹性 
(6)通常在负载均衡正常时，如果消息被消费的速度不小于接收新消息的速度，对于不需要保证可靠不丢失的消息来说，极有可能只处于alpha状态
   对于durable属性设置为true的消息，它一定会进入gamma状态，并且在开启confirm机制时，只有到gamma状态时才会确认消息已经被接受
   若消息消费的速速足够快、内存足够充足，这些消息也不会继续走到下一个状态
```

- #### 惰性队列
```
(1)RabbitMQ从3.6.0版本之后引入了惰性队列(lazy Queue)的概念
   惰性队列会尽可能将消息存入磁盘中，而在消费者消费消息才会将消息加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储
(2)默认情况下，当生产者将消息发送到RabbitMQ时，队列中的消息会尽可能的存储在内存中，这样可以更加快速的将消息发送给消费者
   即使时持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份
   当RabbitMQ需要释放内存时，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作
(3)惰性队列会将接受到的消息直接存入文件系统中，而不管时持久化的会非持久化的，这样可以减少内存的消耗，但是会增加I/O的使用，
   如果消息时持久化的，那么这样的I/O是不可避免的，惰性队列和持久化的消失可以说是最佳组合
   如果惰性队列存储的是非持久化的消息，内存的使用率会一直很稳定，但重启后消息一样会丢失
(4)队列具备两种模式：default和lazy，默认模式为default
   在声明队列时可以通过x-queue-mode参数来设置队列的默认，取值为default和lazy
   Map<String,Object> args = new HashMap<String,Object>();
   args.put("x-queue-mode","lazy");
   channel.queueDeclare("queuename",false,false,false,args);
(5)惰性队列和普通队列相比，只有很少的内存开销
   发送1千万条消息，每条消息的大小为1KB，并且此时没有任何消费者，普通队列的内存消耗为1.2G，而惰性队列只消耗1.5M内存
```

- #### 镜像队列
```
(1)RabbitMQ集群由多个Broker节点组成，尽管交换机和绑定关系能够在单点故障问题上不受影响，但是队列和其上存储的消息取不行，
  因为队列进程及其内容仅仅维护在单个节点上，所以一个节点的失效表现为其对应的队列不可用
(2)引入镜像队列(Mirror Queue)的机制，可以将队列镜像到集群的其他Broker节点上，如果集群中的一个节点失效了，
  队列能够自动切换到镜像中的另一个节点保证服务的可用性
(3)通常，针对每一个配置镜像的队列都包含一个主节点(master)和若干个从节点(slave) 
(4)如果master由于某种原因失败，那么最先加入的slave会被提升为新的master
   发送到镜像队列的所有消息会被同时发往master和所有的slave上，如果此时master挂掉，消息还会在slave上，
   这样slave提升为master的时候也不会丢失消息
(5)除发送消息(basic.publish)外的所有动作都只会向master发送，然后在由master将命令执行的结果广播给各个slave
(6)如果消费者与slave建立连接并进行订阅消费时，其实质都是从master上获取消息，只不过看似是从slave上消费而已
   如消费者与slave建立了TCP连接执行Basic.Get操作，那么首先是有slave将Basic.Get请求发往master，
   再由master准备好数据返回给slave，最后由slave投递给消费者 
```