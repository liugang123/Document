- #### API网关作用
```
* API网关作为系统的统一入口，屏蔽了系统内部各个微服务的细节
* API网关可以与服务治理框架结合，实现自动化的服务实例维护以及负载均衡的路由转发 
* API网关可以实现接口权限校验与微服务业务逻辑的解耦
* 通过API网关中的过滤器，在各生命周期中去校验请求的内容，将原本在对外服务层做的校验前移，
  保证了微服务的无状态性，同时降低了微服务的测试难度，让服务本身更集中关注业务逻辑的处理
```

- #### 基本概念
```
(1)通过Spring Cloud Eureka实现高可用的服务注册中心以及实现微服务的注册和发现，通过Spring Cloud Ribbon或Feign实现服务间的负载均衡的接口调用，
   同时，为了使分布式系统更为健壮，对于依赖的服务调用使用Spring Cloud Hystrix来进行包装，实现线程隔离并加入熔断机制，
   以避免在微服务架构中因个别服务出现异常而引发级联故障蔓延
(2)API网关是一个更为智能的应用服务器，类似于面向对象设计模式的Facade模式，相当于整个微服务结构系统的门面一样，
   所有的外部客户端访问都要经过它来进行调度和过滤，除了实现请求路由、负载均衡、校验过滤等功能外，
   还需要更多能力，如与服务治理框架的结合、请求转发时的熔断机制、服务的聚合等一系列高级功能
(3)Spring Cloud提供了基于Netflix Zuul实现的API网关组件Spring Cloud Zuul
   * 对于服务实例的维护，Spring Cloud Zuul通过与Spring Cloud Eureka进行整合，将自身注册为Eureka服务治理下的应用，
   同时从Eureka中获取所有微服务的实例信息，巧妙的将维护服务实例的工作交给了服务治理框架自动完成，不在需要人工介入。
   * 对于路由规则的维护，Zuul默认将通过以服务名作为ContextPath的方式来创建路由映射，这样的默认设置可以实现大部分路由的需求
   * 对于签名校验、登录校验，Zuul提供了一套过滤机制，开发者可以通过Zuul来创建各种校验过滤器，然后指定哪些规则的请求需要执行校验逻辑，
   只有通过校验的才会被路由到具体的微服务接口，不然就返回错误提示
```

- #### 使用Zuul
```
(1)新建api-geteway命名的网关项目，在pom文件中引入spring-cloud-starter-zuul依赖
   <dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-zuul</artifactId>
   </dependency>
  spring-cloud-starter-zuul依赖不仅包含了Netflix Zuul的核心依赖zuul-core，还包含下面网关服务需要的重要依赖：
  - spring-cloud-strater-hystrix:该依赖用来在网关服务中实现对微服务转发时候的保护机制，
  通过线程隔离和断路器，防止微服务的故障引发API网关资源无法释放，从而影响其他应用的对外服务
  - spring-cloud-starter-ribbon:该依赖用来实现在网关服务进行路由转发时候的客户端负载均衡以及请求重试
  - spring-cloud-starter-actuator:该依赖用来提供常规的微服务管理端点，另外，在Spring Cloud Zuul中还提供了/routes端点来返回当前的所有路由规则
(2)使用注解@EnableZuulProxy来开启Zuul的API网关服务功能
(3)配置路由
   * 传统路由配置方式
     zuul.routes.api-a-url.path = /api-a-url/**
     zuul.routes.api-a-url.url = http://localhost:8080/
   - 该配置定义了发往API网关服务的请求中，所有符合/api-a-url/**规则的访问都将被路由转发到：http://localhost:8080/地址上
   - 配置属性zuul.routes.api-a-url.path中的api-a-url部分为路由的名字，可以任意定义，但是一组path和url映射关系的路由名要相同
   * 面向服务的路由配置
   - Spring Cloud Zuul实现了与Spring Cloud Eureka的无缝整合，可以让路由的path不是映射到具体的url，而是映射到具体的服务，
   而具体的url则交给Eureka的服务发现机制去维护，即面向服务的路由
   - 通过Eureka Server注册中心，zuul能够获取服务的实例清单，以实现path映射服务，在从服务中挑选实例来进行请求转发的完整路由机制
   zuul.routes.api-a.parh = /api-a/**
   zuul.routes.api-a.serviceId = a-service
   
   zuul.routes.api-b.path = /api-b/**
   zuul.routes.api-b.serviceId = b-service
(4)请求过滤
   * Spring Cloud Zuul允许在API网关上通过定义过滤器的方式实现对请求的拦截与过滤
   * 继承ZuulFilter抽象类并实现它定义的4个抽象函数就可以完成对请求的拦截和过滤
   public class AccessFilter extends ZuulFilter {
       
       @Override
       public String filterType() {
           return "pre";
       }
       
       @Override 
       public int filterOrder() {
           return 0;
       }
       
       @Override
       public boolean shouldFilter() {
           return true;
       }
       
       @Override
       public Object run() {
           RequestContext ctx = RequestContext.getCurrentContext();
           
           Object accessToken = request.getParameter("accessToken");
           if(accessToken == null){
               ctx.setSendZuulResponse(false);
               ctx.setResponseStatusCode(401);
               return null;
           }
           return null;
       }
   }
   - filterType():过滤器的类型，决定过滤器在请求的那个生命周期执行，pre表示在请求被路由之前执行
   - filterOrder():过滤器的执行顺序，当请求在一个阶段存在多个过滤器时，需要根据该方法返回的值依次执行
   - shouldFilter():判断过滤器是否需要被执行，true表示该过滤器对所有请求都会生效
   - run():过滤器的具体逻辑，setSendZuulResponse(false)令zuul过滤该请求，不对其进行路由，
     setResponseStatusCode(401)设置了返回的错误码
   * 通过在应用主类中创建具体的Bean启动过滤器
   @EnableZuulProxy
   @SpringCloudApplication
   public class Application {
    
    @Bean
    public AccessFilter accessFilter() {
        return new AccessFilter();
    }
    
   }
```

- #### 请求路由
```

```

- #### 过滤拦截
```

```

- #### 动态加载
```

```