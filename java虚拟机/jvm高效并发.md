
- #### 硬件效率
```
《1》计算机同时做几件事，不仅因为计算机的运算能力强大，
还有计算机的运行速度与它的存储和通信子系统速度的差距太大，
大量的时间花费在磁盘I/O、网络通信或数据库访问上
《2》计算机加入了一层读写尽可能接近处理器的高速缓存（cache）作为内存和处理器之间的缓存
将运算需要的数据复制到缓存中，让运算快速进行
当运算结束后在从缓存同步回内存中
《3》多处理器每个处理器都有自己的高速缓存，而它们共享同一主存，可能导致缓存数据的不一致性
为确保缓存的一致性，各个处理器都遵循规定的协议来操作数据（MSI、MESI、MOSI等）
```

- #### java内存模型
```
《1》jvm规范定义来一种java内存模型（JMM），屏蔽各种硬件和操作系统的内存访问差异，使各个平台达到内存访问数据的一致
《2》JMM主要目标是定义程序中各个变量的访问规则，即虚拟机将变量存储到内存和取出变量这样的底层细节
变量包括实例字段、静态字段和构造数组对象的元素，
不包括局部变量与方法参数，这些都是线程私有的
《3》JMM规定所有的变量都存储在主内存，每个线程都有自己的工作内存，
线程工作内存拷贝了要使用的变量主内存的副本，线程对变量的操作都必须在工作内存中进行，而不能直接读取主内存的变量
不同的线程之间也无法直接访问对方工作内存的变量，线程间变量的传递都需要经过主内存
```
```
graph LR
java线程1--工作内存1-->主内存
java线程2--工作内存2-->主内存
java线程3--工作内存3-->主内存
```
```
主内存主要对应Java堆中的对象时例数据部分，对应与物理硬盘的内存
工作内存对应于虚拟机栈中的部分内容
```
- #### 内存交互操作
```
一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存
JMM定义了8种操作来实现主内存和工作内存之间的交互协议
```

操作 | 区域|说明 
---|---|---
lock(锁定) | 主内存 |将变量标志为线程独占状态
unlock(解锁) |主内存| 将处于锁定状态的变量释放
read(读取) | 主内存 |将变量的值从主内存传输到线程的工作内存中
load(载入)|工作内存|将read的值从主内存中拷贝到工作内存的副本 
use(使用) | 工作内存 |将工作内存变量的值传递给执行引擎
assign(赋值) |工作内存|将执行引擎的值赋值给工作内存 
store(存储) | 工作内存 |将工作内存的变量值传送到主内存中
write(写入) |主内存| 将store操作的变量值放入主内存中

```
8中操作满足的规则
《1》一个变量同一时刻只能被一个线程lock，可以对变量锁定多次
《2》一个变量被lock后，将清空工作内存中此变量的值
```

- #### volatile型变量
```
《1》volatile是虚拟机提供的最轻量级的同步机制
《2》保证对所有线程的看见性，即一条线程修改来变量值，新值对于其他线程可以立即得知
虽然普通变量也是通过主内存来完成数据刷新的，但是不能做到“及时刷新”
《3》java里的运算并非都是原子操作，导致volatile变量在并发下一样不安全
在不符合以下两条规则的运算场景，仍然需要通过加锁
  * 运算经过并不依赖变量的当前值，或能够保证只有单一的线程修改变量值
  * 变量不需要与其他的状态变量共同参与不变的约束
《4》使用volatile的变量可以禁止指令重排序优化,确保程序代码的执行顺序
```
```
public class Singleton{
    public static volatile Singleton instance;
    private Singleton(){
        
    }
    public static Singleton getInstance(){
        if(instance==null){
            synchronized(Singleton.class){
                if(intance==null){
                    instance = new Singleton();
                }
            }
        }
    }
}
```
- JMM特性
```
java内存模型围绕并发过程过程中如何处理原子性、可见性和有序性3个特征建立
* 原子性：jmm直接保证的原子性变量操作（read、load、sign、use、store、write），基本类型的访问读写具备原子性（synchronized关键字）
* 可见性：指当一个线程修改了共享变量的值，其他线程能够立即得知这个变量的修改（volatile、synchronzied关键字）
* 有序性：在同一线程，所有操作都是有序的，
         在一个线程观察另一个线程，所有操作都是无序的（volatile和synchronzied关键字）
```

- 先行发生原则
```
用来判断数据是否存在竞争、线程是否安全的主要依据
不符合“先行发生”的以下规则就无法保证“有序性”
《1》程序次序规则：在一个线程内，按照程序代码顺序执行
《2》管程锁定规定：一个unlock操作先行发生于后面对同一个锁的lock操作
《3》Volatile变量规则：对一个Volatile变量的写操作先行发生于后面对这个变量的读操作
《4》线程启动规则：Thread对象的start方法先行发生于此线程的每个动作
《5》线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测
《6》线程中断规则：对线程interrup方法的调用先行发生于被中断线程的代码检测到中断时间的发生
《7》对象终结规则：一个对象的初始化完成先行发生于它的finalize方法执行
《8》传递性：操作啊a先行发生于操作b，操作b先行发生操作c，a先行发生于c
```
- #### 线程的实现
```
线程实现的3种方式：内核线程实现、用户线程实现和轻量级进程混合实现
《1》内核线程的实现
     * 直接由操作系统内核支持的线程，由内核完成线程的切换，
     * 内核通过调度器对线程调度，并负责将线程任务映射到各个处理器
     *一般不会直接使用内核线程，而是实现内核线程的接口（轻量级进程），轻量级进程和内核线程是1:1的关系
     * 系统代价较高，需要在用户态和内核态来回切换，同时要消耗内核资源，系统支持的轻量级进程是有限的
《2》用户线程实现
     * 完全建立在用户空间的线程上，系统内核不能感知线程的存在
     * 可以不用切换到系统的内核态
《3》用户线程和轻量级进程混合实现
     * 即存在用户线程也存在轻量级进程
     * 用户线程完全建立在用户空间中，轻量级进程作为用户线程和内核线程的桥梁，
       使用内核提供的线程调度给你及处理器映射
```
- #### 线程调度
```
指系统为线程分配处理器使用权的过程，调度方式主要有两种:
《1》协同式线程调度：
     * 线程的执行时间由线程本身来控制，线程执行完成后，主动通知系统切换到另一个线程
     * 线程执行时间不可控制，程序可能会一直阻塞，导致整个系统崩溃
《2》抢占式线程调度：
     * 每个线程将由系统来分配执行时间，线程的切换不由线程本身决定
       线程的阻塞不会引起整个进程的阻塞    
```
- #### java线程状态
```
java语言定义了5种线程状态，任何时间点，一个线程只能有且只有其中一种状态
《1》新建(New):创建后尚未启动的线程
《2》运行(Runable):包含Running和Ready状态，线程可能正在执行，也可能等待CPU分配执行时间
《3》无限期等待(Waiting):等待其他线程显式的唤醒，不会被分配CPU执行时间(Object.wait()、Thread.Sleep())
《4》限期等待(TimeWating):无需等待其他线程显式唤醒，在一定时间有系统主动唤醒，也不会分配CPU执行时间（Thread.Sleep()）
《5》阻塞(Blocked):等待获取一个“排他锁”，这个事件在另一个线程放弃锁时触发，
     进入同步区域，线程进入阻塞状态
《6》结束(Terminated):线程已结束执行，进入结束状态     
```

```
graph LR
new--"strat()" -->Running 
Running --"wait()"-->Waiting
Waiting --"notify()"-->Running
Running -- "synchronized" --> Blocked
Blocked -- "synchronized" --> Running
Running -- "sleep()" --> TimedWaiting
Running -- "run()" --> Terminated
```
- #### 线程安全
```
当多个线程访问一个对象时，如果不考虑这些线程在运行环境的调度和交替执行，
已不需要进行额外的同步，或者在调用方进行任何其他的协调操作，
调用这个对象的行为都可以获取正确的结果，这个对象就是线程安全的
```

- #### 线程安全程度
```
1.不可变
不可变的对象一定是线程安全的
由final关键字修饰的对象带来的不可变是最简单、纯粹的线程安全机制
2.绝对线程安全
不管运行时环境如何，调用者都不需要额外的同步措施
绝对线程安全需要付出很大的代价
3.相对线程安全
通常意义所讲的线程安全
需要保证对这个对象单独的操作是线程安全的，调用时不需要做额外的保障措施
4.线程兼容
对象本身并不是线程安全的，可以通过调用端正确使用同步手段保障对象在并发环境中的安全使用
一个类不是线程安全的就是这种情况
5.线程对立
无论调用端是否采取同步措施，都无法在多线程环境中并发的使用安全对象
线程对立排斥多线程的代码通常都是有害的，应当尽量避免
Thread类的suspend和resume方法一个尝试中段线程，一个尝试恢复线程
并发进行的话，是否采取同步机制，都有死锁的风险
suspend和resume方法已被jdk声明废弃（deprecated）
```

- #### 线程安全方法

- ##### 1.互斥同步(阻塞同步) 
```
* 最常见的并发正确性保障手段
  进行线程的阻塞和唤醒来实现同步，属于一种悲观的并发策略，无论数据是否出现共享竞争，都会加锁
* 同步是指在多线程并发访问共享数据时，保证共享数据在同一时刻只能被一个线程使用
* 互斥是实现同步的一种手段：
临界区(CriticalSection)、互斥量(Mutex)和信号量(Semaphore)都是主要的互斥方式
```
- ##### synchronized关键字

```
* synchronized是java最基本的互斥手段，表现为原生语法的层面的互斥锁
  经过编译后会在同步块前后分别形成moniterEnter和moniterExit指令
* 这两个指令需要一个reference类型的参数来指明要锁定和解锁的对象
  如果没有明确指定referance，synchronized会根据修饰的是实例方法还是类方法，去取对应的对象实例或class对象来作为锁对象
* synchronized是一个重量级操作，在阻塞或唤醒一个线程，
  都需要操作系统来完成，需要从用户态转换到核心状态
* JVM本身会对synchronized进行优化，在通知阻塞线程前加入一段自旋等待过程，
  避免频繁切换到内核态中
```

- ##### ReentrantLock同步
```
* JUC提供的重入锁来实现同步
* 表现为采用lock和unlock方法配合try/finally语句块来完成
* 相比synchronized增加了高级功能：
  等待可中断：当持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待
  公平锁：当多个线程等待同一个锁，必须按照锁的时间顺序获得锁；
          非公平锁在锁释放时，任何一个等待的线程都有机会获取锁
          synchronized是非公平锁，ReentrantLock默认也是非公平锁，可以通过构造函数参数实现公平锁
  锁可以绑定多个条件：Reentrant对象可以绑定多个Condition对象
```

- ##### 2.非阻塞同步
```
* 基于冲突检测的乐观并发策略：
不需要将线程挂起，先进行操作，如果其他线程没有争用共享数据，操作成功
如果共享数据被争用，产生冲突，在采取补偿措施
* JUC的整数原子类，compareAndSet和getAndIncrement等方法都使用类CAS操作
* CAS操作会存在“ABA”问题
```

```
public final int incrementAndGet(){
    for(;;){
        int current = get();
        int next = current + 1;
        if(compareAndSet(current,next)){
            return next;
        }
    }
}
```

- ##### 3.无同步方案
```
* 不涉及共享数据的情况，就无需任何同步措施来保证数据的正确性
* 还有一些代码本身就是线程安全的：
  1.可重入代码：
  纯代码，在代码执行的任何时刻，转而去执行另一段代码，
  在控制权返回后，原来的程序不会出现错误
  共同的特性：不依赖存储在堆上的数据和公共的系统资源，
              用到的状态量都有参数传入，不调用非可重入的方法
  2.线程本地存储：
    如果一段代码需要的数据必须与其他代码共享，这些共享数据的代码是否能保证在同一个线程中
    如果可以就把共享数据的可见范围限制在同一个线程之内
    经典的web交互模型“一个请求对应一个服务器线程”，使得许多web服务器应用
    都可以使用线程本地存储来解决线程安全问题
```

- #### 锁优化(高效并发)
```
HotSpot虚拟机团队在jdk1.6版本实现了各种锁优化的技术
```

- ##### 自旋锁和自适应锁
```
自旋锁：线程并行执行时，让后面请求锁的线程“稍等一下”
        并不放弃处理器的执行时间，看看持有锁的线程是否很快释放锁
        如果锁被占用的时间很短，自旋等待的效果就很好
        如果锁被占用的时间很长，就会白白的消耗处理器资源，自旋的默认参数是10次
自适应自旋锁：如果在同一个锁对象上，自旋等待刚刚获取锁，并且持有锁的线程正在执行，
            那么虚拟机会认为当前自旋很可能再次成功
            如果自旋很少获取锁成功，那在以后的自旋中，虚拟机可能会忽略调自旋过程
```

- ##### 锁消除
```
虚拟机即时编译器在运行时，会检测被代码要求同步的代码，
是否可能会不存在数据共享的问题，从而进行锁消除
```

- ##### 锁粗化
```
如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至解锁出现在循环体内
虚拟机对这些零碎的操作，会把加锁同步的范围扩展到整个操作序列的外部
```

- ##### 轻量级锁
```
对于绝对部分锁，在整个同步周期内都是不存在竞争的
如果没有竞争，轻量级锁使用CAS操作就避免了使用互斥量的开销
如果存在竞争，除了互斥量的开销外，还额外发生了CAS操作
因此，有竞争的情况下，轻量级的锁会比传统的重量级锁更慢
```

- ##### 偏向锁
```
轻量级锁在无竞争情况下使用CAS操作去消除同步使用的互斥量
偏向锁就是在无竞争情况下，把整个同步都取消掉，CAS操作也不用进行
```