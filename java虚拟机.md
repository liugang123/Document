## Class文件结构
- #### 实例
 
```
/**
 * 车辆信息
 *
 */
public class Car {

    /**
     * vin码
     */
    private final String vin;

    /**
     * 座位数
     */
    private int seat;

    /**
     * 价格
     */
    private Double price;

    /**
     * 构造函数
     */
    public Car(String vin) {
        System.out.println("======= 构造方法前 =======");
        System.out.println(this.toString());
        this.vin = vin;
    }
    
    @Override
    public String toString() {
        return "Car{" +
                "vin='" + vin + '\'' +
                ", seat=" + seat +
                ", price=" + price +
                '}';
    }
}
```

```
    public  static void main(String[] args) {
        Car aodi = new Car("LSGVF5308KY015058");
        System.out.println("======= 构造方法后 ========");
        System.out.println(aodi.toString());
    }
```

```
======= 构造方法前 =======
Car{vin='null', seat=0, price=null}
======= 构造方法后 =======
Car{vin='LSGVF5308KY015058', seat=0, price=null}
```

- #### 迷惑

```
 1.在对象被new之前，被创建之前；由seat=0，推断，对象的成员变量，在构造函数之前，已经被赋值过，否则，这个0是怎么来的？
 2.seat=0，是在类的层面被赋值的？还是在对象的层面？
```

- #### 类的定义: 如何描述一个类的信息  
  
  **1.类信息** 

CalssName | ClassAccess|ClassDesc | SuperClass | interfaces
---|--- |---|---|---
Car | public| 车辆信息类 |Object|null
    
  **2.字段信息**
  
FieldName | FieldAccess | FieldType |FieldDesc |ClassName 
---|--- |--- |---|---
vin | private | String| vin码 | Car 
seat | private | int  | 座位数 | Car 
price | private | Double | 价格 | Car 


FieldName | FieldAccess | FieldType |FieldDesc |ClassName | FieldIndex | FieldId
---|--- |--- |---|---| --- |---
vin | private | String| vin码 | Car | package/car.vin S |  1
seat | private | int  | 座位数 | Car | package/car.seat i | 2
price | private | Double | 价格 | Car | package/car.price D |3

 FieldIndex | FieldId
 ---|--- |--- 
 package/car.vin S |  #1
 package/car.seat i | #2
 package/car.price D |#3
 
 accessFlag | nameIndex | nameTypeIndex
 ---|---|--- |--- 
 private | vin   |  #1
 private | seat  |  #2
 private | price |  #3
 
 
  accessFlag | nameIndex | nameTypeIndex
 ---|---|--- |--- 
 2 | #11   |  #1
 2 | #12  |  #2
 2 | #13 |  #3
 
 
 **3.方法信息**

MethodName | MethodAccess| MethodDesc | MethodParams| MethodReturn|ClassName 
---|---|---|---|---|---| ---
Car | public | 构造函数 | string vin | null | Car
toString  | public |  | | String  | Car 

MethodName | MethodAccess| MethodDesc | MethodParams| MethodReturn|ClassName | MethodIndex | MethodId
---|---|---|---|---|---| ---|---
Car | public | 构造函数 | vin S,...,... | null | Car | package/car.car(vin S)  | 4
toString  | public |  | | String  | Car | package/car.toString() S |5

MethodIndex | MethodId
 ---|---
 package/car.car(vin S)  | #4
 package/car.toString() S |#5
 
 accessFlag | nameIndex | nameTypeIndex
 ---|---|--- |--- 
 public | car   |  #4
 public | toString  |  #5

 accessFlag | nameIndex | nameTypeIndex
 ---|---|--- |--- 
 1 | #44   |  #4
 1 | #55  |  #5
 
 - #### 官方语言
 
  ```
  java通过class文件的方式实现了类或接口的定义
  
  class文件只包含两种数据类型:无符号数和表
  
  无符号数:基本数据类型,u1,u2代表1个字节,两个字节的数据
  表:多个无符号数或其他表构成的复合数据类型,_info结尾
  
  ```
 
- #### class文件格式


类型 | 名称| 数量| 描述
---|---|---|---
 u4| magic | 1 | 4个字节存储的数据表示当前文件是class文件,'CA FE BA BE'即class文件的魔数   
 u2| minor_version|1| 2个字节存储的数据表示class文件的次版本号
 u2| major_version|1| 2个字节存储的数据表示class文件的主版本号
 u2| constant_pool_count|1|2个字节存储的数据表示常量池中的常量总数
 cp_info|constant_pool|constant_pool_count-1|常量池表
 u2|access_flags| 1| 2个字节存储的数据表示类或接口的访问权限
 u2|this_class|1| 2个字节存储的数据表示当前类的标识
 u2|super_class|1|2个字节存储的数据表示当前类的继承的类
 u2|interface_count|1|2个字节存储的数据表示当前类实现的接口数量
 u2|interfaces|interface_count| 当前类实现接口的标识
 u2|fields_count|1|2个字节存储的数据表示当前类字段的数量
 field_info|fields|fields_count| 字段表
 u2|method_count|1|2和字节存储的数表示当前类的方法数量
 method_info|methods|method_count|方法表
 u2|attribute_count|1|2个字节存储的数据表示当前类的属性数量
 arrtibute_info|attributes|attribute_count|当前类的属性表
 
 - #### class文件结构
 ```
1.  魔数与class文件版本
2.  常量池
3.  访问标志
4.  类索引、父类索引、接口索引
5.  字段表集合 
6.  方法表集合
7.  属性表集合
 ```
 
 - #### 常量池
 ```
 1.存储字面量: 文本字符串(如'java'),常量(如圆周率T)
 2.存储符号引用: 类和接口的全限定名,字段的名称和描述符,方法的名称和描述符
 ```
 
类型 | 标识| 描述 | 实例
---|---|---|---
Utf8_info | 1 | utf_8编码的字符串 | 'java'  
Integer_info |3 |整型字面量 | I
Float_info |4| 浮点型字面量 | F
Double_info|6 | 双精度浮点型字面量| D
Long_info|5 | 长整型字面量 | L
Class_info|7| 类或接口的符号引用 | #21
String_info|8| 字符串类型字面量|'java' 
Field_info|9| 字段的符号引用|  #19.#48
Method_info|10|类中方法的符号引用| #55.#56
interfaceMethod_info|11|接口中方法的符号引用|#80.#90
nameAndType_info|12|字段或方法的部分符号引用|#74:#78
methodHandle_info|15| 方法句柄|
methodType_info|16|标识方法类型|
InvokeDynamic_info|18|方法的动态调用点

- #### 字段表
```
1.字段名称、类型引用常量池中的常量表示
2.字段的作用域（public，private，protected），类变量（static），可变性（final），并发可见性（final）用标志位表示
```

类型 | 名称|数量|描述|实例
---|---|---|---|---
u2 | access_flags| 1| 两个字节存储的数据表示字段的标志位|Ox0001,Ox0002
u2 | name_Index |1| 两个字节存储的数据表示字段的简单名称常量池引用 | #21 
u2 | descriptor_index|1|两个字节存储的数据表示字段的描述信息（字段的数据类型）常量池的引用| #24
u2 | attribute_count|1| 两个字节存储的数据表示字段属性的数量|
attribute_info|attributes| 字段属性表|constantValue常量值属性
```
  Ox0001 #21 #24 ==> public vin String 
  final static int m=123 ==》 字段constantValue属性值指向123
```
- #### 方法表


类型 | 名称|数量|描述|实例
---|---|---|---|---
u2 | access_flags|1|2个字节存储的数据表示方法的访问标志 | OX0001
u2 | name_index| 1 | 2个字节存储的数据表示方法的简单名称常量池的引用 | #45 
u2 | desc_index|1 | 2个字节存储的数据表示方法的描述信息(方法参数、返回值)常量池的引用 | #68
u2 | attr_count|1| 2个字节存储的数据表示方法属性的数量| 
attr_info| attrs|attr_count|方法属性表|code属性

```
 方法中的java代码，经过编译器编译成字节码指令后，存放在方法code属性里面
```

- #### 属性表
```
 在Class文件、字段表、方法表都可以携带自己的属性表集合，原来描述某些专有数据
```


属性名 | 使用位置 | 含义
---|---|---
Code | 方法表| java代码编译成的字节码指令
ConstantValue | 字段表 | final关键字定义的常量值
Deprecated|类、方法表、字段表|被声明为deprecated的方法和字段
Exceptions|方法表| 方法抛出的异常
InnerClasses|类文件|内部类列表
LineNumberTable|code属性| java源码的行号和字节码指令的对应关系
LocalVariableTable|code属性| 方法的局部变量描述


## 类加载机制
 
 - #### 加载
```
1.通过全类名获取定义此类的二进制字节流
2.将字节流所代表的静态存储结构转换为方法区的运行时数据结构
3.在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口
```

 - #### 类加载器
```
  1.启动类加载器：将<java_home>\lib目录中的类库加载到虚拟机内存中（如rt.jar）
  2.扩展类加载器：负责加载<java_home>\lib/ext目录中的类库 3.应用程序类加载器：负责加载用户类路径（classPath）上所指定的类库
```
- #### 双亲委派模型
```
  1.除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。
  2.类加载器之间的‘双亲’关系不是通过继承的关系实现，而是使用组合的关系复用父加载器的代码 
  3.确保在各个类加载器中加载的类都是唯一的
```
- #### 验证
```
1.文件格式的验证：字节流是否符合Class文件的规范
  《1》是否已魔数OxCAFEBABE开头
  《2》文件主、次版本号是否在虚拟机处理范围
  《3》文件是否有被删除或附加其他信息
2.元数据验证：对字节码信息进行语义分析，是否符合java语言规范的要求
  《1》类是否有父类
  《2》类是否继承不允许继承的类
  《3》非抽象类是否实现了继承接口方法或抽象方法
  《4》类中的字段和方法是否与父类产生矛盾
3.字节码验证：确保程序语义是合法的、符合逻辑的
  《1》保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作
  《2》保证跳转指令不会跳转到方法体以外的字节码指令上
  《3》保证方法体中的类型转换有效
4.符号引用验证：针对类自身以外的信息进行验证匹配，如
  《1》符号引用中字符串描述的全限定名是否能找到对应的类
  《2》在指定类中是否存在符合描述符的方法和字段
  《3》符号引用中的类、方法、字段是否能被当前类访问 
```

- #### 准备
```
正式为类变量分配内存并设置类变量的初始值，类变量仅是static修饰的变量，不包含实例变量 
```
- #### 解析
```
 将常量池的符号引用替换为直接引用的过程。
 符号引用：一组符号描述所引用的目标，使用时无歧义的定位到目标即可，符号引用于虚拟机引用无关
 直接引用：可以是直接指向目标的指针，相对偏移量或目标句柄
 类或接口的解析、字段解析、类方法解析、接口方法解析
```
- #### 初始化
```
 执行类构造器<clinit>()方法的过程
```

- #### 对象内存结构
```
对象在内存中存储的布局划分为：对象头、实例数据、对齐填充
对象头：包含两部分数据，一部分存储对象自身运行的数据，如哈希值、GC分代年龄、锁状态标志，另一部分是类型指针，通过这个指针可以确定当前对象是哪个类的实例
实列数据：存储对象的有效数据，各种类型字段的内容
对齐填充：没有特殊含义，也不是必须存在，起占位符的作用，确保对象的大小是8字节的整数倍
```
## 虚拟机内存区域

```
 java虚拟机在执行java程序过程中会把管理的内存划分若干不同的数据区域，会包含堆，方法区，虚拟机栈，本地方法栈，程序计数器几个运行时数据区域。
```
- ####  程序计数器
```
 1.字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制（顺序执行，选择，循环，异常处理）
 2.在多线程情况下，用于记录当前线程的执行位置，当线程切换回来可以知道线程上次运行的位置
 3.程序计数器是较小的内存空间，唯一一个不会出现OOM的内存区域，他的生命周期与线程相同。
```
- #### 虚拟机栈
```
 1.虚拟机栈是线程私有的，生命周期和线程相同
 2.描述java方法执行的内存模型，每个方法执行都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息
```
- #### 本地方法栈
```
 本地方法区为虚拟机使用到的Native方法服务，本地方法执行时，本地方法栈会创建一个栈帧，用于存储本地方法的局部变量，操作数栈，动态链接，方法出口信息，本地方法执行完 毕后相应的栈帧也会出栈并释放内存空间。
```

- #### 堆
```
 1.堆是虚拟机管理内存的最大一块区域，在虚拟机启动时创建，所有线程共享的一块内存区域
 2.目的用来存放对象实例，几乎所有的对象实列和数组都在堆上分配内存
```

- #### 方法区
```
 1.与堆内存一样，是各个线程共享的内存区域
 2.用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
 3.JDK1.8版本，方法区被彻底移除了，取而代之的是元空间，元空间使用直接内存
```

- #### 运行时常量池
```
1.运行时常量池是方法区的一部分
2.用于存储java代码编译期间生成的各种字面量和符号引用
3.JDK1.7之后的版本虚拟机已经将运行时常量池从方法区中移了出来，在java堆中另外开辟一块区域用于存放运行是常量池
```

- #### 直接内存
```
1.直接内存不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域
2.通过存储在java堆中的缓存区（Buffer）对象作为直接内存的引用进行操作，避免了java堆和native堆之间来回复制数据
```

## 对象回收
```
   程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而亡。而方法区和堆内存的分配和回收都是动态的，垃圾收集器正是关注这部分内存的分配和回收的。
```

- #### 是否存活
```
 1.引用计数法
   每当对象被引用，计数器加1，当引用失效，计数器就减1，计数器为0的对象将不再被使用
   实现简单，效率高，但很难解决对象之间相互循环引用的问题
 2.可达性分析
   通过一系列称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，节点所走过的路程称为引用链，当对象没有到GC Roots 的任何引用链的话，证明对象是不可用的
   可以作为GC Roots的对象：
   虚拟机栈中引用的对象
   方法区中静态属性引用的对象
   方法区中常量引用的对象
   本地方法栈中引用的对象
 3.强引用
   在程序代码中普遍存在的，如Object obj = new Object();如果一个对象具有强引用,垃圾收集器永远不会回收掉被引用的对象
 4.软引用
   描述一些还有用但并非必需的对象，在系统将要发生内存溢出异常之前，将会把这些对象列入垃圾回收范围，如果这次回收还没有足够的空间，才会抛出内存溢出异常
 5.弱引用
   用来描述非必需对象，比软引用更弱一些，软引用对象只能生存到下一次垃圾收集之前
 6.虚引用
   也称为幽灵引用或幻影引用，不会影响对象的生存时间，任何时候都可以被垃圾收集器回收，需引用主要用来跟踪对象被垃圾回收的状态活动 
```

- #### 标记-清除算法
```
 标记：标记出所有需要回收的对象
 清除：统一回收所有被标记的对象
 效率问题：标记和清除效率都不高
 空间问题：会产生大量不连续的内存碎片
```

- #### 复制算法
```
将可用内存分为大小相等的两块，每次只使用一块，当这块内存用完了，就将还存活的对象复制到另一块上，再把使用的内存空间清理掉，这样每次内存回收都是对内存区间一半就行回收 实现简单，运行高效，只是内存缩小为原来的一半
对象存活率较高时就会就行较多的复制操作，效率会降低
```

- #### 标记-整理算法
```
 与“标记-清除”算法一样，但后续不是直接对可回收对象进行清除，而是让存活的对象都向一端移动，然后清除掉边界以外的内存
```

- #### 分代收集算法
```
将java堆划分为新生代和老年代，根据各个代的特点采用适当的收集算法
新生代：每次垃圾收集时会有大批对象死去，只有少量存活，选择复制算法
老年代：对象存活率高，没有额外空间进行分配担保，选择标记-清除算法或标记-整理算法
```

- #### 垃圾收集器
```
收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。
直到现在还没有最好的垃圾收集器出现，更没有万能的垃圾收集器，根据具体的应用场景选择合适的垃圾收集器 
```

 - #### Serial 收集器
 ```
 单线程收集器，在完成垃圾收集的工作过程中，必须暂停其他所有工作线程（stop the world）
 由于没有线程交互的开销，简单高效，对于运行在Client模式下的虚拟机来说是很好的选择
 ```
 
 - #### ParNew 收集器
 ```
 是Serial收集器的多线程版本，除了使用多线程进行垃圾回收外，其余行为（控制参数、收集算法、回收策略等）和Serial收集器完全一样
 ```
 
 - #### Paraller Scavenge 收集器
 ```
 使用复制算法的并行多线程收集器，注重垃圾回收的吞吐量（高效率的利用CPU）
 ```
 
 - #### Serial Old 收集器
 ```
 是Serial收集器的老年代版本，单线程收集器，使用‘标记-清除’算法
 ```
 
 - #### Parallel Old 收集器
 ```
 是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法，在注重吞吐量以及CPU资源的场合，都可以优先考虑Parallel Scavenge收集器和Parallel Old收集器
 ```
 
 - #### CMS 收集器
```
 Concurrent Mark Sweep收集器真正意义上的并发收集器，第一次实现了让垃圾收集线程和用户线程同时工作
 以获取最短回收停顿时间为目标的收集器，非常符合注重用户体验的应用上使用
```

- #### G1 收集器
```
 Garbage_First收集器面向服务端应用的垃圾收集器。
 主要针对多处理器设备及大容量内存的机器，尽可能满足GC停顿时间要求的同时，还具备高吞吐量性能特征
```

- #### 对象分配策略
```
 java提倡的内存自动管理解决两个问题：给对象分配内存、回收分配给对象的内存
 从垃圾回收的角度，由于收集器基本采用分代垃圾收集算法，java堆可细化为：新生代和老年代(entired)，在细致一点，新生代可以细化为eden空间、From Survivor、To Survivor区。大部分情况，对象会首先在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活，则进入To Survivor区，并且对象年龄加1，当年龄增加到一定程度（默认15），就会被晋升到老年代，经过这次GC后，Eden区和From区都被清空，同时，From和To会交换角色，在下一次GC时，To区域始终保存是空的。
```
``` 
  1.对象优先在Eden分配
    大多数情况，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机发生一次Minor GC（新生代GC），java对象大多具有朝生夕死的特性，Minor GC非常频繁
  2.大对象直接进入老年代
   
  3.长期存活的对象将进入老年代
  4.动态对象年龄判定
  5.空间分配担保
```